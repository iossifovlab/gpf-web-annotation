#!/bin/bash

shopt -s extdebug
shopt -s inherit_errexit
set -e

. build-scripts/loader-extended.bash

loader_addpath build-scripts/

# shellcheck source=build-scripts/libmain.sh
include libmain.sh
# shellcheck source=build-scripts/libbuild.sh
include libbuild.sh
# shellcheck source=build-scripts/libdefer.sh
include libdefer.sh
# shellcheck source=build-scripts/liblog.sh
include liblog.sh
# shellcheck source=build-scripts/libopt.sh
include libopt.sh

function main() {
  local -A options
  libopt_parse options \
    stage:all preset:fast clobber:allow_if_matching_values build_no:0 generate_jenkins_init:no expose_ports:no -- "$@"

  local preset="${options["preset"]}"
  local stage="${options["stage"]}"
  local clobber="${options["clobber"]}"
  local build_no="${options["build_no"]}"
  local generate_jenkins_init="${options["generate_jenkins_init"]}"
  local expose_ports="${options["expose_ports"]}"

  libmain_init iossifovlab.gpf-web-annotation gpf_web_annotation
  libmain_init_build_env \
    clobber:"$clobber" preset:"$preset" build_no:"$build_no" generate_jenkins_init:"$generate_jenkins_init" expose_ports:"$expose_ports" \
    iossifovlab.iossifovlab-gpf-containers
  libmain_save_build_env_on_exit
  libbuild_init stage:"$stage" registry.seqpipe.org

  defer_ret build_run_ctx_reset_all_persistent
  defer_ret build_run_ctx_reset

  build_stage "Cleanup"
  {
    build_run_ctx_init "container" "ubuntu:22.04"
    defer_ret build_run_ctx_reset
    build_run rm -rf ./data ./import ./results ./playwright/test-results ./logs
    build_run mkdir -p ./logs
  }

  build_stage "Draw build dependencies"
  {
    build_deps_graph_write_image 'build-env/dependency-graph.svg'
  }

  build_stage "Prepare e2e cluster"
  {
    # create network
    {
      local -A ctx_network
      build_run_ctx_init ctx:ctx_network "persistent" "network"
      build_run_ctx_persist ctx:ctx_network
    }

    # setup mysql
    {
      build_run_local docker pull mysql:8.0

      local -A ctx_mysql
      build_run_ctx_init ctx:ctx_mysql "persistent" "container" "mysql:8.0" "cmd-from-image" \
        --hostname mysql \
        --network "${ctx_network["network_id"]}" \
        -e "MYSQL_DATABASE=gpf" \
        -e "MYSQL_USER=seqpipe" \
        -e "MYSQL_PASSWORD=secret" \
        -e "MYSQL_ROOT_PASSWORD=secret" \
        -e "MYSQL_PORT=3306" \
        -- \
        --character-set-server=utf8 --collation-server=utf8_bin --default-authentication-plugin=mysql_native_password
      defer_ret build_run_ctx_reset ctx:ctx_mysql

      build_run ctx:ctx_mysql ./scripts/wait-for-it.sh localhost:3306 --timeout=360

      build_run_ctx_persist ctx:ctx_mysql
    }

    # run MailHog
    {
      local docker_img_iossifovlab_mailhog
      docker_img_iossifovlab_mailhog="$(e docker_img_iossifovlab_mailhog)"

      local -A ctx_mailhog
      build_run_ctx_init ctx:ctx_mailhog "persistent" "container" "$docker_img_iossifovlab_mailhog" \
          "cmd-from-image" "no-def-mounts" \
          'ports:1025,8025->8025' --hostname mailhog --network "${ctx_network["network_id"]}"
      defer_ret build_run_ctx_reset ctx:ctx_mailhog
      build_run_ctx_persist ctx:ctx_mailhog
    }
  }

  build_stage "Run e2e data import"
  {

    # prepare data-hg19-startup data
    {
      build_run_ctx_init "local"
      defer_ret build_run_ctx_reset

      local iossifovlab_gpf_image_ref
      iossifovlab_gpf_image_ref=$(e docker_img_iossifovlab_gpf)

      # adjust instance config
      {
        # setup context
        build_run_ctx_init "container" "${iossifovlab_gpf_image_ref}" \
          --network "${ctx_network["network_id"]}"
        defer_ret build_run_ctx_reset
      }

      # GRR cache
      {
        build_run_local bash -c "mkdir -p ./cache"
        build_run_local bash -c "touch ./cache/grr_definition.yaml"
        build_run_local bash -c 'cat > ./cache/grr_definition.yaml << EOT
id: "default"
type: "url"
url: "https://grr.seqpipe.org/"
cache_dir: "/wd/cache/grrCache"
EOT
'
      }

      # import data
      {
        # # setup context
        build_run export WD=/wd
        build_run export DAE_DB_DIR=/wd/gpf_e2e_instance
        build_run export GRR_DEFINITION_FILE=/wd/cache/grr_definition.yaml

        build_run source /gpf/bin/activate

        build_run grr_cache_repo \
          --grr /wd/cache/grr_definition.yaml \
          --instance /wd/gpf_e2e_instance/gpf_instance.yaml

        build_run /wd/gpf_e2e_instance/import_data.sh
      }
    }
  }


  build_stage "Run gpf-full container"
  {
    local iossifovlab_gpf_full_image_ref
    iossifovlab_gpf_full_image_ref=$(e docker_img_iossifovlab_gpf_full)

    local -A ctx_gpf_full
    build_run_ctx_init ctx:ctx_gpf_full "persistent" "container" \
      "$iossifovlab_gpf_full_image_ref" "cmd-from-image" \
      'ports:8080->8080,9001' --hostname gpf \
      --network "${ctx_network["network_id"]}" \
      -v ./logs:/logs \
      -e APACHE2_VHOST_LISTEN_PORT="8080" \
      -e DAE_DB_DIR=/wd/gpf_e2e_instance \
      -e DAE_PHENODB_DIR=/wd/gpf_e2e_instance/pheno \
      -e GRR_DEFINITION_FILE=/wd/cache/grr_definition.yaml \
      -e WDAE_DB_NAME="gpf" \
      -e WDAE_DB_USER="seqpipe" \
      -e WDAE_DB_PASSWORD="secret" \
      -e WDAE_DB_HOST="mysql" \
      -e WDAE_DB_PORT="3306" \
      -e WDAE_SECRET_KEY="123456789012345678901234567890123456789012345678901234567890" \
      -e WDAE_ALLOWED_HOST="*" \
      -e WDAE_DEBUG="True" \
      -e WDAE_LOG_DIR="/logs" \
      -e WDAE_PUBLIC_HOSTNAME="gpf" \
      -e GPF_PREFIX="gpf" \
      -e WDAE_PREFIX="gpf" \
      -e WDAE_EMAIL_HOST="mailhog" \
      -e WDAE_EMAIL_VERIFICATION_ENDPOINT="http://gpf:8080/gpf"

    defer_ret build_run_ctx_reset ctx:ctx_gpf_full

    # wait for gunicorn
    build_run ctx:ctx_gpf_full /wd/scripts/wait-for-it.sh localhost:9001 --timeout=360
    # wait for apache
    build_run ctx:ctx_gpf_full /wd/scripts/wait-for-it.sh localhost:8080 --timeout=360

    # create users, create oauth app
    build_run ctx:ctx_gpf_full /wd/scripts/reset_dev.sh



    build_run_ctx_persist ctx:ctx_gpf_full
  }

  build_stage "Build e2e run environment"
  {
    local iossifovlab_node_tests_base_image_tag
    iossifovlab_node_tests_base_image_tag=$(e docker_img_iossifovlab_node_tests_base_tag)


    build_run_local rm -rf ./build-scripts-tmp
    build_run_local mkdir ./build-scripts-tmp
    build_run_local cp package.json ./build-scripts-tmp
    build_run_local dd status=none of=./build-scripts-tmp/Dockerfile <<'EOT'

ARG REGISTRY=""
ARG BASE_IMAGE_TAG=latest
FROM ${REGISTRY}iossifovlab-node-tests-base:${BASE_IMAGE_TAG}

ADD package.json /root
RUN bash -c 'cd /root; cat package.json | jq ".dependencies * .devDependencies"  | sed -n -e "s/^\s\+\"//" -e "s|\": \"|@|" -e "s|\",\?$||p" | xargs -d "\n" npm install --global'
RUN bash -c "cd /; npx playwright install --with-deps"
ENV NODE_PATH=/usr/lib/node_modules

EOT

    build_docker_image_create "gpf-web-annotation-run" ./build-scripts-tmp ./build-scripts-tmp/Dockerfile "$iossifovlab_node_tests_base_image_tag"
  }

  build_stage "Run e2e"
  {
    local gpf_e2e_run_image_ref
    gpf_e2e_run_image_ref="$(e docker_img_gpf_e2e_run)"

    build_run_ctx_init "container" "$gpf_e2e_run_image_ref" \
      --network "${ctx_network["network_id"]}" \
      --ipc=host

    build_run /wd/scripts/wait-for-it.sh gpf:9001 --timeout=360
    build_run /wd/scripts/wait-for-it.sh gpf:8080 --timeout=360

    # wait for instance
    build_run curl http://gpf:8080/gpf/api/v3/datasets

    build_run bash -x -c '
        echo "container-ip";
        ip addr;

        echo "starting xvfb in background"
        Xvfb -screen 0 2560x1440x24 :99 &
        xvfb_pid="$!"
        export DISPLAY=:99

        echo "polling xvfb for display"
        while ! xdotool getmouselocation >/dev/null 2>&1; do
          sleep 0.2;
        done;
        echo "xvfb display is up"

        echo "starting vnc server in background"
        x11vnc_port_file=$(mktemp)
        x11vnc -nevershared -forever > "$x11vnc_port_file" &
        x11vnc_pid="$!"

        echo "wait for vnc server to become ready"
        i=0
        while ! grep --max-count=1 -e "^PORT=[0-9]\+$" "$x11vnc_port_file"; do
          i=$(($i + 1))
          if [ $i -gt 50 ]; then
            echo "vnc server is not up after 10 seconds"
            exit 1;
          fi;
          sleep 0.2;
        done;
        echo "vnc server is up"

        echo "move mouse at top left"
        mouselocation=""
        while [ "$mouselocation" != "x:0 y:0" ]; do
          mouselocation="$(xdotool mousemove 0 0 getmouselocation 2> /dev/null)";
          mouselocation="$(echo "$mouselocation" | cut -f 1,2 -d " ")"
          sleep 0.2;
        done;
        echo "mouse is at top left"

        echo "run playwright in background"
        JENKINS=1 npx playwright test --headed --workers 1 &
        playwright_pid="$!"

        echo "wait for chromium window and make it fullscreen"
        set +x
        waitcounter=0
        waitcountermax=100
        waitdebuglog=""
        windowposgeometry=""
        while [ "$windowposgeometry" != "Position:0,0(screen:0)Geometry:2560x1440" ] && [ "$waitcounter" -lt "$waitcountermax" ]; do
          windowrootid="$(printf "%d" "$(xwininfo -root | grep "Window id: " | grep -o -e "0x[0-9a-fA-F]\+")")"
          windowid="$(xdotool search --all --onlyvisible --class "^" | grep -v --line-regexp -e "$windowrootid")"
          windowposgeometry="$(xdotool windowmove "$windowid" 0 0 windowsize "$windowid" 2560 1440 getwindowgeometry "$windowid" 2>/dev/null)";
          windowposgeometry="$(echo "$windowposgeometry" | tail -n +2 | sed -e "{N; s/\s//g;}")"
          sleep 0.2;
          waitdebuglog+="windowrootid: [$windowrootid], windowid: [$windowid], windowposgeometry=[$windowposgeometry], waitcounter=[$waitcounter]"'$'\n''
          waitcounter=$(($waitcounter + 1))
        done;
        if [ "$waitcounter" -eq "$waitcountermax" ]; then
          echo "wait for chromium window and make it fullscreen debug log:"
          echo "$waitdebuglog"
        fi
        set -x
        echo "chromium window is fullscreen"

        echo "wait for playwright to finish"
        wait "$playwright_pid";

        echo "kill xvfb and vnc server"
        kill -9 "$xvfb_pid" "$x11vnc_pid";

        echo "wait for processes to die"
        wait' \
           || true
  }

  build_stage "Lint"
  {
    local iossifovlab_node_base_image_ref
    iossifovlab_node_base_image_ref=$(e docker_img_iossifovlab_node_base)

    build_run_ctx_init "container" "$iossifovlab_node_base_image_ref" \
      --network "${ctx_network["network_id"]}" \
      --ipc=host

    build_run bash -c './node_modules/eslint/bin/eslint.js "**/*.{html,ts}" --format checkstyle >ts-lint-report.xml || echo "eslint exited with $?"'
  }

  build_stage "Post Cleanup"
  {
    build_run_ctx_init "container" "ubuntu:22.04"
    defer_ret build_run_ctx_reset
    build_run rm -rf ./data
    build_run gzip ./logs/wdae-debug.log
  }
}

main "$@"
